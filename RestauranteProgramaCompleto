/*
 * Simulación de Sistema de Gestión de Pedidos en Restaurante
 * Lenguaje: C (Linux)
 * Uso de fork(), memoria compartida y semáforos POSIX
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <semaphore.h>
#include <string.h>
#include <signal.h>
#include <time.h>

#define MAX_PEDIDOS 10
#define MAX_COMBOS 3

// Definición de estructura de pedido
typedef struct {
    int id;
    char estado[20]; // "Nuevo", "Cocinado", "Empaquetado", "Finalizado"
    char combo[20];
} Pedido;

// Estructura compartida
typedef struct {
    Pedido pedidos[MAX_PEDIDOS];
    int contador_pedidos;
    int finalizar;
} SharedData;

// Variables globales
SharedData *datos;
sem_t *sem_mutex; // Para acceso a estructura compartida

char *combos[MAX_COMBOS] = {"Stacker", "BigMac", "Wopper"};

void cargar_combo_aleatorio(char *dest) {
    int r = rand() % MAX_COMBOS;
    strcpy(dest, combos[r]);
}

void crear_pedido() {
    while (!datos->finalizar) {
        sem_wait(sem_mutex);

        if (datos->contador_pedidos >= MAX_PEDIDOS) {
            sem_post(sem_mutex);
            break;
        }

        for (int i = 0; i < MAX_PEDIDOS; i++) {
            if (strcmp(datos->pedidos[i].estado, "") == 0) {
                datos->pedidos[i].id = i + 1;
                strcpy(datos->pedidos[i].estado, "Nuevo");
                cargar_combo_aleatorio(datos->pedidos[i].combo);
                datos->contador_pedidos++;
                printf("[TOMADOR PEDIDO] Pedido %d creado (%s)\n", datos->pedidos[i].id, datos->pedidos[i].combo);
                break;
            }
        }

        sem_post(sem_mutex);
        sleep(1);
    }
}

void avanzar_estado(const char *estado_actual, const char *estado_nuevo, const char *rol) {
    while (!datos->finalizar) {
        sem_wait(sem_mutex);
        int procesado = 0;
        for (int i = 0; i < MAX_PEDIDOS; i++) {
            if (strcmp(datos->pedidos[i].estado, estado_actual) == 0) {
                strcpy(datos->pedidos[i].estado, estado_nuevo);
                printf("[%s] Pedido %d %s\n", rol, datos->pedidos[i].id, estado_nuevo);
                procesado = 1;
                break;
            }
        }
        sem_post(sem_mutex);
        if (procesado)
            sleep(1);
        else
            usleep(100000); // Espera activa breve si no hay trabajo
    }
}

void cocinar() {
    avanzar_estado("Nuevo", "Cocinado", "COCINERO");
}

void empaquetar() {
    avanzar_estado("Cocinado", "Empaquetado", "EMPAQUETADOR");
}

void repartir() {
    avanzar_estado("Empaquetado", "Finalizado", "REPARTIDOR");
}

void limpiar_recursos() {
    sem_close(sem_mutex);
    sem_unlink("/sem_mutex");
    munmap(datos, sizeof(SharedData));
    shm_unlink("/mem_pedidos");
}

int main() {
    srand(time(NULL));

    int shm_fd = shm_open("/mem_pedidos", O_CREAT | O_RDWR, 0666);
    ftruncate(shm_fd, sizeof(SharedData));
    datos = mmap(NULL, sizeof(SharedData), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);

    memset(datos, 0, sizeof(SharedData));

    // Inicialización de semáforo
    sem_mutex = sem_open("/sem_mutex", O_CREAT, 0666, 1);

    pid_t pids[10];

    // Crear hijos
    pids[0] = fork(); if (pids[0] == 0) { crear_pedido(); exit(0); }
    pids[1] = fork(); if (pids[1] == 0) { cocinar(); exit(0); }
    pids[2] = fork(); if (pids[2] == 0) { cocinar(); exit(0); }
    pids[3] = fork(); if (pids[3] == 0) { empaquetar(); exit(0); }
    pids[4] = fork(); if (pids[4] == 0) { repartir(); exit(0); }
    pids[5] = fork(); if (pids[5] == 0) { repartir(); exit(0); }
    pids[6] = fork(); if (pids[6] == 0) { repartir(); exit(0); }

    printf("[PADRE] Presione ENTER para terminar...\n");
    getchar();
    datos->finalizar = 1;

    for (int i = 0; i < 7; i++) waitpid(pids[i], NULL, 0);

    printf("[PADRE] Pedidos completados:\n");
    for (int i = 0; i < MAX_PEDIDOS; i++) {
        if (strcmp(datos->pedidos[i].estado, "Finalizado") == 0)
            printf("  Pedido %d (%s): %s\n", datos->pedidos[i].id, datos->pedidos[i].combo, datos->pedidos[i].estado);
    }

    limpiar_recursos();
    return 0;
}
